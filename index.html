<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LIBRVRY</title>

  <meta property="og:type" content="website">
  <meta property="og:title" content="LIBRVRY">
  <meta property="og:description" content="Be quiet">
  <meta property="og:image" content="https://librvry.com/favicon/social-card.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:url" content="https://librvry.com">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="LIBRVRY">
  <meta name="twitter:description" content="Be quiet">
  <meta name="twitter:image" content="https://librvry.com/favicon/social-card.png">

  <link rel="icon" type="image/png" href="favicon/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="favicon/favicon.svg" />
  <link rel="shortcut icon" href="favicon/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png" />
  <meta name="apple-mobile-web-app-title" content="LIBRVRY" />
  <link rel="manifest" href="favicon/site.webmanifest" />

  <style>
    :root{
      color-scheme: light;
      --book-width: 300px;
      --bg: #D2D2D2;
    }

    body{
      margin:0;
      min-height:100vh;
      background: var(--bg);
      overflow:hidden;
      user-select:none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    .stage{
      position: relative;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      overscroll-behavior: none;
    }

    .book{
      position:absolute;
      left: 50%;
      top: 50%;
      transform-origin: 50% 90%;
      border-radius: 0;
      overflow: visible;
      background: #FFFFFF;
      box-shadow: 0 14px 40px rgba(0,0,0,0.18);
      will-change: transform;
      pointer-events: none; /* add-only */
    }

    .book img{
      width: var(--w, var(--book-width));
      max-width: 100%;
      height: auto;
      display:block;
      pointer-events:none;
      -webkit-user-drag:none;
      user-drag:none;
    }
  </style>
</head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KQGX2CS3KF"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-KQGX2CS3KF');
</script>

<body>
  <div class="stage" id="stage"></div>

  <script>
(() => {
  const stage = document.getElementById("stage");

  // ---------- Tunables ----------
  const MAX_ONSCREEN = 14;
  const MIN_STACK = 6;

  // Default autoplay interval (ms)
  const DEFAULT_AUTOPLAY_INTERVAL = 200;

  // Pause autoplay after real user input for this long:
  const RESUME_AFTER_MS = 2200;

  const OFFSCREEN = 1100;

  const MIN_W = 190;
  const MAX_W = 420;

  // Never upscale: clamp each image to 75% of its native pixel width
  const SCALE_NATIVE = 0.75;

  // ---------- URL params ----------
  const params = new URLSearchParams(location.search);

  // autoplay on/off
  const autoplayRaw = (params.get("autoplay") || "").trim().toLowerCase();
  const AUTOPLAY =
    !(autoplayRaw === "0" || autoplayRaw === "false" || autoplayRaw === "off" || autoplayRaw === "no");

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  // autoplay speed override
  // ?speed=700 or ?autoplay=700
  function getAutoplayInterval(){
    const speedRaw = (params.get("speed") || "").trim();
    let raw = speedRaw;

    // If no ?speed, allow numeric ?autoplay
    if (!raw && autoplayRaw && !Number.isNaN(parseInt(autoplayRaw, 10))) {
      raw = autoplayRaw;
    }

    if (!raw) return DEFAULT_AUTOPLAY_INTERVAL;

    const ms = parseInt(raw, 10);
    if (Number.isNaN(ms)) return DEFAULT_AUTOPLAY_INTERVAL;

    return clamp(ms, 50, 5000);
  }

  const AUTOPLAY_INTERVAL = getAutoplayInterval();

  // ---------- State ----------
  let covers = [];
  let idx = 0;
  let autoplayTimer = null;

  // IMPORTANT: this tracks ONLY real user input (not autoplay adds)
  let lastUserInputAt = performance.now();
  function noteUserInput(){
    lastUserInputAt = performance.now();
  }

  // ---------- Helpers ----------
  function hashToUnitFloat(str){
    let h = 2166136261;
    for (let i = 0; i < str.length; i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0) / 4294967296;
  }

  function baseRotationFor(src, maxDeg = 12){
    const u = hashToUnitFloat(src);
    return (u * 2 - 1) * maxDeg;
  }

  // dir=0 => all angles (autoplay vibe)
  function randomEntryVector(dir = 0){
    if (dir === -1) return { x: -OFFSCREEN, y: (Math.random() * 600 - 300) };
    if (dir ===  1) return { x:  OFFSCREEN, y: (Math.random() * 600 - 300) };
    const angle = Math.random() * Math.PI * 2;
    return { x: Math.cos(angle) * OFFSCREEN, y: Math.sin(angle) * OFFSCREEN };
  }

  function getTargetWidthPx(){
    const w = Math.floor(window.innerWidth * 0.82);
    return clamp(w, MIN_W, MAX_W);
  }

  function setGlobalWidthVar(){
    const w = getTargetWidthPx();
    document.documentElement.style.setProperty("--book-width", w + "px");
    return w;
  }

  function nextCover(){
    if (covers.length === 0) return null;
    const src = covers[idx % covers.length];
    idx++;
    return src;
  }

  function computeCenterY(ar, widthPx){
    return ar ? (-(widthPx * ar) / 2) : 0;
  }

  function setTransform(el, x, y, rotDeg, scale, centerY){
    el.style.transform =
      `translate(-50%, ${centerY}px) translate(${x}px, ${y}px) rotate(${rotDeg}deg) scale(${scale})`;
  }

  function ensureStack(minCount = MIN_STACK){
    if (!covers.length) return;
    let count = stage.querySelectorAll(":scope > .book").length;
    while (count < minCount) {
      addBook({ animateIn: false, dir: 0 });
      count++;
    }
  }

  // ---------- Core ----------
  async function loadCovers(){
    const res = await fetch("/covers.json", { cache: "no-store" });
    if (!res.ok) throw new Error(`GET /covers.json failed: ${res.status}`);
    const list = await res.json();
    if (!Array.isArray(list) || list.length === 0) throw new Error("No covers found.");
    covers = list;

    setGlobalWidthVar();
    ensureStack(MIN_STACK);

    if (AUTOPLAY) startAutoplay();
  }

  function addBook({ animateIn = true, dir = 0 } = {}){
    const src = nextCover();
    if (!src) return;

    const book = document.createElement("div");
    book.className = "book";

    const rot = baseRotationFor(src, 12) + (Math.random() * 6 - 3);
    const scale = 1;

    const driftX = (Math.random() * 18 - 9);
    const driftY = (Math.random() * 10 - 5);

    const img = document.createElement("img");
    img.src = src;
    img.alt = "";
    img.draggable = false;

    book.appendChild(img);
    stage.appendChild(book);

    // Cap DOM size (remove oldest behind)
    while (stage.querySelectorAll(":scope > .book").length > MAX_ONSCREEN) {
      const first = stage.querySelector(":scope > .book");
      if (first) first.remove();
      else break;
    }

    const entry = randomEntryVector(dir);

    const onLoaded = () => {
      const natW = img.naturalWidth || 0;
      const natH = img.naturalHeight || 0;
      const ar = (natW && natH) ? (natH / natW) : 0;

      const targetW = getTargetWidthPx();
      const maxNativeW = natW ? (natW * SCALE_NATIVE) : targetW;
      const clampedW = Math.min(targetW, maxNativeW);

      document.documentElement.style.setProperty("--book-width", targetW + "px");
      book.style.setProperty("--w", clampedW + "px");

      const centerY = computeCenterY(ar, clampedW);

      book.style.transition = "none";
      setTransform(book, entry.x + driftX, entry.y + driftY, rot, scale, centerY);
      void book.offsetWidth;

      if (!animateIn) {
        setTransform(book, driftX, driftY, rot, scale, centerY);
        return;
      }

      book.style.transition = "transform 300ms cubic-bezier(.2,.85,.2,1)";
      setTransform(book, driftX, driftY, rot, scale, centerY);
    };

    img.addEventListener("load", onLoaded, { once: true });
    img.addEventListener("error", () => book.remove(), { once: true });
    if (img.complete) onLoaded();

    ensureStack(MIN_STACK);
  }

  function startAutoplay(){
    clearInterval(autoplayTimer);
    autoplayTimer = setInterval(() => {
      const now = performance.now();
      if (now - lastUserInputAt < RESUME_AFTER_MS) return;
      addBook({ animateIn: true, dir: 0 });
    }, AUTOPLAY_INTERVAL);
  }

  // ---------- Virtual Scroll Nav (DOWN adds only) ----------
  const VS = {
    THRESHOLD_PX: 20,
    COOLDOWN_MS: 120,
    MAX_STEPS_PER_SEC: 20,
    INERTIA_DECAY: 0.94,
    MIN_VELOCITY: 0.15,
    VELOCITY_GAIN: 0.9,
  };

  (function installVirtualScrollAdd(stageEl){
    let intent = 0;
    let lastFire = 0;
    let lastStepAt = 0;

    let touchActive = false;
    let lastY = 0;
    let lastT = 0;
    let velocity = 0;
    let rafId = null;

    const canFire = () => {
      const now = performance.now();
      if (now - lastFire < VS.COOLDOWN_MS) return false;
      const minGap = 1000 / VS.MAX_STEPS_PER_SEC;
      if (now - lastStepAt < minGap) return false;
      return true;
    };

    const fireAdd = () => {
      if (!canFire()) return;
      addBook({ animateIn: true, dir: 0 });
      const now = performance.now();
      lastFire = now;
      lastStepAt = now;
    };

    const consumeIntent = () => {
      while (intent >= VS.THRESHOLD_PX && canFire()) {
        fireAdd();
        intent -= VS.THRESHOLD_PX;
      }
      if (intent < 0) intent *= 0.5;
    };

    const addDelta = (deltaY) => {
      intent += deltaY;
      consumeIntent();
    };

    function stopInertia(){
      if (rafId != null) cancelAnimationFrame(rafId);
      rafId = null;
    }

    function startInertia(){
      stopInertia();
      let v = velocity * VS.VELOCITY_GAIN;

      const tick = () => {
        if (Math.abs(v) < VS.MIN_VELOCITY) { rafId = null; return; }
        const dt = 16;
        const delta = v * dt * 10;
        if (delta > 0) addDelta(delta);
        v *= VS.INERTIA_DECAY;
        rafId = requestAnimationFrame(tick);
      };

      rafId = requestAnimationFrame(tick);
    }

    const onWheel = (e) => {
      e.preventDefault();
      if (e.deltaY > 0) {
        noteUserInput();
        addDelta(e.deltaY);
      }
    };

    const onTouchStart = (e) => {
      if (!e.touches || e.touches.length !== 1) return;
      noteUserInput();
      touchActive = true;
      stopInertia();
      lastY = e.touches[0].clientY;
      lastT = performance.now();
      velocity = 0;
    };

    const onTouchMove = (e) => {
      if (!touchActive || !e.touches || e.touches.length !== 1) return;
      e.preventDefault();
      noteUserInput();

      const now = performance.now();
      const y = e.touches[0].clientY;

      // finger up => dy positive => add
      const dy = lastY - y;
      const dt = Math.max(1, now - lastT);

      const v = dy / dt;
      velocity = velocity * 0.7 + v * 0.3;

      if (dy > 0) addDelta(dy);

      lastY = y;
      lastT = now;
    };

    const onTouchEnd = () => {
      if (!touchActive) return;
      touchActive = false;
      startInertia();
    };

    stageEl.addEventListener("wheel", onWheel, { passive: false });
    stageEl.addEventListener("touchstart", onTouchStart, { passive: false });
    stageEl.addEventListener("touchmove", onTouchMove, { passive: false });
    stageEl.addEventListener("touchend", onTouchEnd, { passive: false });
    stageEl.addEventListener("touchcancel", onTouchEnd, { passive: false });
  })(stage);

  // ---------- Resize ----------
  let resizeRAF = null;
  function onResize(){
    cancelAnimationFrame(resizeRAF);
    resizeRAF = requestAnimationFrame(() => {
      setGlobalWidthVar();
      // (We only update --book-width; per-book --w is set on load, leaving transforms stable.)
    });
  }
  window.addEventListener("resize", onResize);

  loadCovers()
    .then(() => onResize())
    .catch(err => console.error(err));
})();
  </script>
</body>
</html>
