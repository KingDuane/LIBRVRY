<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LIBRVRY</title>

  <style>
    :root{
      color-scheme: light;
      --book-width: 320px; /* global target width (responsive) */
      --bg: #D2D2D2;
    }

    body{
      margin:0;
      min-height:100vh;
      background: var(--bg);
      overflow:hidden;
      user-select:none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    .stage{
      position: relative;
      width: 100vw;
      height: 100vh;
      touch-action: pan-y;
    }

    .book{
      position:absolute;
      left: 50%;
      top: 50%;
      transform-origin: 50% 90%;
      border-radius: 0;
      overflow: visible;
      background: #FFFFFF;
      box-shadow: 0 14px 40px rgba(0,0,0,0.18);
      will-change: transform;
      cursor: grab;
    }

    .book.dragging{ cursor: grabbing; }

    /* Per-book clamp: --w is set in JS as min(responsiveWidth, naturalWidth) */
    .book img{
      width: var(--w, var(--book-width));
      max-width: 100%;
      height: auto;
      display:block;
      pointer-events:none;
      -webkit-user-drag:none;
      user-drag:none;
    }
  </style>
</head>

<body>
  <div class="stage" id="stage"></div>

  <script>
    (() => {
  const stage = document.getElementById("stage");

  // ---------- Tunables ----------
  const MAX_ONSCREEN = 14;

  const AUTOPLAY = true;
  const AUTOPLAY_INTERVAL = 700;

  const OFFSCREEN = 1100;         // px
  const SWIPE_DISTANCE = 120;      // px
  const SWIPE_VELOCITY = 650;      // px/s

  // Responsive width limits (px)
  const MIN_W = 190;
  const MAX_W = 420;

  // NEW: Clamp each image to 75% of its native pixel width (never upscale)
  const SCALE_NATIVE = 0.75;

  // ---------- State ----------
  let covers = [];
  let idx = 0;
  let autoplayTimer = null;
  let userInteracting = false;

  // ---------- Helpers ----------
  function hashToUnitFloat(str){
    let h = 2166136261;
    for (let i = 0; i < str.length; i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0) / 4294967296;
  }

  function baseRotationFor(src, maxDeg = 12){
    const u = hashToUnitFloat(src);
    return (u * 2 - 1) * maxDeg;
  }

  function randomEntryVector(dir = 0){
    // dir: -1 (from left), +1 (from right), 0 (any angle)
    if (dir === -1) return { x: -OFFSCREEN, y: (Math.random() * 600 - 300) };
    if (dir ===  1) return { x:  OFFSCREEN, y: (Math.random() * 600 - 300) };

    const angle = Math.random() * Math.PI * 2;
    return { x: Math.cos(angle) * OFFSCREEN, y: Math.sin(angle) * OFFSCREEN };
  }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function getTargetWidthPx(){
    // 82vw on small screens, clamped to avoid huge covers on desktop
    const w = Math.floor(window.innerWidth * 0.82);
    return clamp(w, MIN_W, MAX_W);
  }

  function setGlobalWidthVar(){
    const w = getTargetWidthPx();
    document.documentElement.style.setProperty("--book-width", w + "px");
    return w;
  }

  function nextCover(){
    if (covers.length === 0) return null;
    const src = covers[idx % covers.length];
    idx++;
    return src;
  }

  function setTransform(el, x, y, rotDeg, scale, centerY){
    el.style.transform =
      `translate(-50%, ${centerY}px) translate(${x}px, ${y}px) rotate(${rotDeg}deg) scale(${scale})`;
  }

  function computeCenterY(ar, widthPx){
    return ar ? (-(widthPx * ar) / 2) : 0;
  }

  // ---------- Core ----------
  async function loadCovers(){
    const res = await fetch("/covers.json", { cache: "no-store" });
    if (!res.ok) throw new Error(`GET /covers.json failed: ${res.status}`);
    const list = await res.json();
    if (!Array.isArray(list) || list.length === 0) throw new Error("No covers found.");
    covers = list;

    setGlobalWidthVar();

    // seed pile
    const seed = Math.min(6, covers.length);
    for (let i = 0; i < seed; i++) addBook({ animateIn: false });

    if (AUTOPLAY) startAutoplay();
  }

  function addBook({ animateIn = true, dir = 0 } = {}){
    const src = nextCover();
    if (!src) return;

    const book = document.createElement("div");
    book.className = "book";
    book.dataset.src = src;

    // stable-ish personality + slight jitter
    const rot = baseRotationFor(src, 12) + (Math.random() * 6 - 3);
    const scale = 1;

    // subtle drift so pile feels organic
    const driftX = (Math.random() * 18 - 9);
    const driftY = (Math.random() * 10 - 5);

    // store base pose
    book.dataset.rot = String(rot);
    book.dataset.scale = String(scale);
    book.dataset.x = String(driftX);
    book.dataset.y = String(driftY);

    const img = document.createElement("img");
    img.src = src;
    img.alt = "";
    img.draggable = false;

    book.appendChild(img);
    stage.appendChild(book);

    while (stage.children.length > MAX_ONSCREEN) {
      stage.removeChild(stage.firstElementChild);
    }

    refreshInteractivity();

    const entry = randomEntryVector(dir);

    const onLoaded = () => {
      const natW = img.naturalWidth || 0;
      const natH = img.naturalHeight || 0;
      const ar = (natW && natH) ? (natH / natW) : 0;

      book.dataset.nw = String(natW);
      book.dataset.ar = String(ar);

      // Responsive target width (viewport-based)
      const targetW = getTargetWidthPx();

      // NEW: Never exceed 75% of native width (and never upscale)
      const maxNativeW = natW ? (natW * SCALE_NATIVE) : targetW;

      // Final displayed width for THIS book
      const clampedW = Math.min(targetW, maxNativeW);

      // Apply widths
      document.documentElement.style.setProperty("--book-width", targetW + "px");
      book.style.setProperty("--w", clampedW + "px");

      // Centering uses the actual rendered width
      const centerY = computeCenterY(ar, clampedW);
      book.dataset.centerY = String(centerY);

      // Start offscreen
      book.style.transition = "none";
      setTransform(book, entry.x + driftX, entry.y + driftY, rot, scale, centerY);

      // Force reflow so Chrome commits start transform
      void book.offsetWidth;

      if (!animateIn) {
        setTransform(book, driftX, driftY, rot, scale, centerY);
        return;
      }

      // Animate into place
      book.style.transition = "transform 620ms cubic-bezier(.2,.85,.2,1)";
      setTransform(book, driftX, driftY, rot, scale, centerY);
    };

    img.addEventListener("load", onLoaded, { once: true });
    img.addEventListener("error", () => book.remove(), { once: true });

    if (img.complete) onLoaded();
  }

  function dismissTop(dir = 1){
    const top = stage.lastElementChild;
    if (!top || !top.classList.contains("book")) return;

    const centerY = parseFloat(top.dataset.centerY || "0");
    const rot = parseFloat(top.dataset.rot || "0");
    const scale = parseFloat(top.dataset.scale || "1");

    const currX = parseFloat(top.dataset.x || "0");
    const currY = parseFloat(top.dataset.y || "0");

    const targetX = currX + dir * OFFSCREEN;
    const targetY = currY + (Math.random() * 200 - 100);

    top.style.transition = "transform 420ms cubic-bezier(.2,.7,.2,1)";
    setTransform(top, targetX, targetY, rot, scale, centerY);

    top.addEventListener("transitionend", function handler(){
      top.removeEventListener("transitionend", handler);
      top.remove();
      refreshInteractivity();
    });
  }

  function startAutoplay(){
    clearInterval(autoplayTimer);
    autoplayTimer = setInterval(() => {
      if (userInteracting) return;
      addBook({ animateIn: true, dir: 0 });
    }, AUTOPLAY_INTERVAL);
  }

  // ---------- Swipe / Drag on top book ----------
  function refreshInteractivity(){
    const books = [...stage.querySelectorAll(".book")];
    for (const b of books) {
      b.classList.remove("dragging");
      b.onpointerdown = null;
      b.onpointermove = null;
      b.onpointerup = null;
      b.onpointercancel = null;
    }

    const top = stage.lastElementChild;
    if (!top || !top.classList.contains("book")) return;
    attachDrag(top);
  }

  function attachDrag(book){
    let dragging = false;
    let startX = 0;
    let dx = 0;

    let lastX = 0;
    let lastT = 0;
    let vx = 0;

    book.onpointerdown = (e) => {
      if (e.pointerType === "mouse" && e.button !== 0) return;

      userInteracting = true;
      dragging = true;
      dx = 0;

      book.classList.add("dragging");
      book.style.transition = "none";

      startX = e.clientX;
      lastX = startX;
      lastT = performance.now();
      vx = 0;

      try { book.setPointerCapture(e.pointerId); } catch {}
    };

    book.onpointermove = (e) => {
      if (!dragging) return;

      const xNow = e.clientX;
      dx = xNow - startX;

      const now = performance.now();
      const dt = Math.max(1, now - lastT);
      const instV = ((xNow - lastX) / dt) * 1000;
      vx = 0.8 * vx + 0.2 * instV;

      lastX = xNow;
      lastT = now;

      const baseX = parseFloat(book.dataset.x || "0");
      const baseY = parseFloat(book.dataset.y || "0");
      const rot = parseFloat(book.dataset.rot || "0");
      const scale = parseFloat(book.dataset.scale || "1");
      const centerY = parseFloat(book.dataset.centerY || "0");

      const dragY = clamp(Math.abs(dx) * 0.05, 0, 24);
      setTransform(book, baseX + dx, baseY + dragY, rot, scale, centerY);
    };

    const end = () => {
      if (!dragging) return;
      dragging = false;

      book.classList.remove("dragging");

      const shouldSwipe =
        Math.abs(dx) > SWIPE_DISTANCE || Math.abs(vx) > SWIPE_VELOCITY;

      if (!shouldSwipe) {
        const baseX = parseFloat(book.dataset.x || "0");
        const baseY = parseFloat(book.dataset.y || "0");
        const rot = parseFloat(book.dataset.rot || "0");
        const scale = parseFloat(book.dataset.scale || "1");
        const centerY = parseFloat(book.dataset.centerY || "0");

        book.style.transition = "transform 300ms cubic-bezier(.2,.9,.2,1)";
        setTransform(book, baseX, baseY, rot, scale, centerY);

        userInteracting = false;
        return;
      }

      dismissTop(dx > 0 ? 1 : -1);
      setTimeout(() => { userInteracting = false; }, 350);
    };

    book.onpointerup = end;
    book.onpointercancel = end;
  }

  // ---------- Keyboard navigation ----------
  function onKeyDown(e){
    if (e.key === "ArrowRight") {
      addBook({ animateIn: true, dir: 1 });
    } else if (e.key === "ArrowLeft") {
      dismissTop(-1);
    }
  }

  // ---------- Responsive recenter + no-upscale recompute ----------
  let resizeRAF = null;
  function onResize(){
    cancelAnimationFrame(resizeRAF);
    resizeRAF = requestAnimationFrame(() => {
      const targetW = setGlobalWidthVar();

      const books = [...stage.querySelectorAll(".book")];
      for (const b of books){
        const natW = parseFloat(b.dataset.nw || "0") || targetW;
        const ar = parseFloat(b.dataset.ar || "0");

        // NEW: Clamp to 75% of native width (and never upscale)
        const maxNativeW = natW * SCALE_NATIVE;
        const clampedW = Math.min(targetW, maxNativeW);

        b.style.setProperty("--w", clampedW + "px");

        const centerY = computeCenterY(ar, clampedW);
        b.dataset.centerY = String(centerY);

        const x = parseFloat(b.dataset.x || "0");
        const y = parseFloat(b.dataset.y || "0");
        const rot = parseFloat(b.dataset.rot || "0");
        const scale = parseFloat(b.dataset.scale || "1");

        b.style.transition = "none";
        setTransform(b, x, y, rot, scale, centerY);
      }
    });
  }

  // init
  window.addEventListener("keydown", onKeyDown);
  window.addEventListener("resize", onResize);

  loadCovers()
    .then(() => onResize())
    .catch(err => console.error(err));
})();
  </script>
</body>
</html>